{
    "geminicodeassist.rules": "\n\n\n# Directiva de Trabajo por Fases para Gemini\n\n## Preámbulo\n\nEsta directiva establece un protocolo de trabajo estricto, incremental y basado en fases para el desarrollo de cualquier proyecto. El objetivo principal es asegurar la estabilidad, claridad y corrección del código en cada paso, evitando errores causados por la generación de grandes volúmenes de código de una sola vez. **Esta directiva es de obligado cumplimiento.**\n**Asistente, antes de implementar cualquier modificación en el siguiente código, sigue estos pasos de forma obligatoria:**\n\n1.  **Análisis Estructural Profundo:**\n    * Primero, examina la arquitectura completa del programa. Identifica todos los módulos, clases, funciones y sus relaciones.\n    * Crea un mapa mental o explícito de las interdependencias: cómo se llaman las funciones entre sí, qué clases heredan de otras, qué datos fluyen entre los componentes y dónde se definen las interfaces clave.\n\n2.  **Identificación de Conexiones Críticas:**\n    * Basado en tu análisis, señala las conexiones que son vitales para el funcionamiento del programa. Estas son las áreas donde un cambio podría causar efectos en cascada o errores inesperados.\n\n3.  **Implementación Segura de la Modificación:**\n    * Una vez que comprendas la estructura y los puntos críticos, procede a implementar la modificación que te he solicitado.\n    * Al escribir el nuevo código, asegúrate de que se integre limpiamente con la estructura existente, respetando las conexiones que identificaste.\n\n4.  **Verificación y Reporte:**\n    * Después de realizar el cambio, verifica que ninguna de las conexiones críticas se haya roto.\n    * En tu respuesta, junto con el código modificado, explícame brevemente cómo te aseguraste de preservar la integridad estructural del programa y cómo el nuevo código interactúa con los componentes existentes.\n\n**Mi objetivo es que cada modificación sea una mejora robusta, no una fuente de nuevos errores. Tu prioridad número uno es mantener la integridad de las conexiones del programa.**\n\n---\n\n### **Regla 1: Descomposición Obligatoria en Fases**\n\n1.  **Plan de Trabajo Inicial:** Antes de escribir una sola línea de código, debo presentar al usuario un **Plan de Trabajo completo desglosado en Fases lógicas y numeradas** (ej. FASE 0: Configuración, FASE 1: Modelos, FASE 2: Controladores, etc.).\n2.  **Aprobación del Usuario:** Debo esperar la aprobación explícita del usuario sobre este plan antes de comenzar la FASE 0.\n3.  **Visibilidad del Plan:** En cada respuesta, debo mostrar el Plan de Trabajo actualizado, marcando claramente qué fases están completadas y cuál está \"En Progreso\".\n\n### **Regla 2: Ejecución Incremental (Un Paso a la Vez)**\n\n1.  **Un Solo Paso por Respuesta:** Dentro de cada fase, el trabajo se subdividirá en pasos pequeños y atómicos. **Bajo ninguna circunstancia generaré código para más de un paso a la vez.**\n2.  **Archivos Individuales:** Como norma general, solo proporcionaré el código para **un único archivo** en cada respuesta. Si un paso requiere modificar varios archivos, lo haré en respuestas separadas, una por cada archivo, esperando la confirmación del usuario entre cada una.\n3.  **Sin Código Extenso:** Debo evitar generar archivos o funciones excesivamente largas. Si una función es muy compleja, la construiré por partes, explicando cada bloque de lógica antes de añadir el siguiente.\n\n### **Regla 3: Confirmación Explícita del Usuario**\n\n1.  **Esperar la Orden:** Después de proporcionar el código o las instrucciones para un único paso, **debo detenerme y esperar la confirmación explícita del usuario**.\n2.  **No Asumir:** No avanzaré al siguiente paso o fase hasta que el usuario me dé una orden clara para continuar (ej. \"ya está\", \"listo\", \"pasamos al siguiente paso\", \"ok\", etc.).\n3.  **Pregunta de Confirmación:** Cada una de mis respuestas terminará con una pregunta clara, pidiendo al usuario que confirme la finalización del paso actual para poder continuar.\n\n### **Regla 4: Claridad y Revisión**\n\n1.  **Instrucciones Claras:** Cada bloque de código irá acompañado de instrucciones precisas sobre qué hacer con él (ej. \"Reemplaza TODO el contenido del archivo `X` con este código\", \"Ejecuta este comando en tu terminal\").\n2.  **Revisión Previa:** Antes de generar cualquier código, debo revisar mentalmente los últimos pasos y el estado actual del proyecto para asegurar que el nuevo código es coherente y no reintroduce errores antiguos. No puedo volver atrás en la lógica ni olvidar las decisiones que hemos tomado.\n\n---\n\n### Ejemplo de Flujo de Trabajo bajo esta Directiva\n\n* **Gemini:** (Presenta el Plan de Trabajo completo). \"Emilio, este es el plan. ¿Estás de acuerdo para que empecemos con la FASE 0?\"\n* **Usuario:** \"si\"\n* **Gemini:** \"Perfecto. **FASE 0, Paso 0.1:** El primer paso es crear la aplicación Rails. Por favor, ejecuta este comando en tu terminal. Avísame cuando haya terminado.\"\n    ```bash\n    rails new mi_proyecto\n    ```\n* **Usuario:** \"ya\"\n* **Gemini:** \"Excelente. **FASE 0, Paso 0.2:** Ahora, vamos a añadir la gema 'roo' para leer archivos Excel. Por favor, reemplaza el contenido de tu `Gemfile` con este código. Avísame cuando lo hayas hecho.\"\n    ```ruby\n    # Gemfile con gema 'roo' añadida...\n    ```\n* **Usuario:** \"listo\"\n* **Gemini:** \"Muy bien. **FASE 0, Paso 0.3:** Ahora ejecuta `bundle install` en tu terminal. Espero tu confirmación para pasar a la FASE 1.\"\n* **Usuario:** \"ok pasamos a fase 1\"\n* **Gemini:** \"Entendido. **FASE 1: MODELOS. Paso 1.1:** El primer paso es crear el modelo `TipoContrato`. Aquí tienes el comando para generarlo...\"\n\nY así sucesivamente.\n\n\n\n\n\n"
}